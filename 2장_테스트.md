# 2장. 테스트




## 🐫 테스트 개요

### 1. 단위 테스트란?

* 어떤 코드를 작성했을 때, 작성한 프로그래머 자신이 그 코드에대한 확신을 얻기 위함

* 테스트를 하지 않았을 시, 차후에 발생하는 문제점이 어디에서 발생했는지 찾는 고생이 더해지며, 찾기도 어렵다.

* 테스트는 **단위 테스트**를 기본으로 한다.

* **단위 테스트** : 작은 단위의 코드에 대해 테스트를 수행하는 것

* 단위 테스트는 **하나의 관심사**에 집중해서 효율적으로 테스트할 만한 범위로 수행해야 한다. (단일 책임 원칙과 비슷)

* 단위 테스트를 이용한 **확인대상**, **조건**은 간단하고 명확할수록 좋다.


### 2. 자동수행 테스트 코드

* 테스트는 자동으로 수행되도록 코드로 만들어지는 것이 중요하다.

* 테스트를 위한 입력값을 자동으로 가지게 만든다.

* 결과값에 대한 검증도 자동으로 값을 비교하도록 만든다.


### 3. DAO를 이용한 단위 테스트 자동화

1. **INSERT** 작업을 수행하는 코드 작성

1. **SELECT** 작업을 수행하는 코드 작성

1. **INSERT** 했던 데이터와, **SELECT** 한 데이터를 각각 비교

    * 하나라도 일지하지 않을 시, ``테스트 실패 (속성명)`` 의 형식으로 실패 메시지 출력

    * 모두 일치할 경우, ``테스트 성공`` 의 형식으로 성공 메시지 출력




## 🐫 JUnit (테스트 프레임워크)

* JUnit으로 사용할 **테스트 메서드**의 조건

    1. ``public`` 한정자인 메서드일 것

    1. 반환값이 **void**일 것

    1. 인자값이 없을 것

    1. 테스트 메서드에 **@Test** 애노테이션을 붙일 것

* 라이브러리 : ``com.springsource.org.junit-4.7.0.jar``

* **모든 코드의 수정 후에는, 꼭 관련 테스트를 실행하자!**


### 1. JUnit 작성하기

* **INSERT**값과 **SELECT**값을 비교할 때 사용했던 ``if()``대신, **``assertThat()``** 메서드를 사용한다.

* ``assertThat(①, ②)``

    * ① 인자값 : 비교할 값 1

    * ② 인자값 : ``CoreMatcher``의 스테틱 메서드인 **``is(비교할 값 2)``**

        ``CoreMatcher.is()``사용하기 : **``import static org.hamcrest.CoreMatchers.is;``** 필요

    * 두 인자값이 일치하면, 테스트 성공 메시지를 출력하고, 실패하면 실패 메시지와 내역을 출력해 준다.


### 2. JUnit 실행하기

> ``JUnitCore``를 이용한 JUnit 실행

* JUnit은 스프링과 같은 Java로 만든 프로그램이기 때문에 ``main()``메서드에서 실행시켜줘야 한다.

* JUnit을 실행시킬 클래스에 ``main()``메서드를 만들고 **``@Test``**메서드를 가지는 클래스를 실행시키면 JUnit이 동작한다.

```java
    import org.hamcrest.CoreMatchers;
    import org.junit.Assert;
    import org.junit.Test;
    
    import static org.junit.Assert.assertThat;
    import static org.hamcrest.CoreMatchers.is;
    
    public class MyTest {
        @Test
        public void 테스트_메서드() {

            assertThat(값1, is(값2));
        }
    }
```

```java
    import org.junit.runner.JUnitCore;

    public class MyJUnitTester {
        public static void main(String[] args) {
            JUnitCore.main("tester.MyTest");
        }
    }
```

> ``IDE(이클립스)``를 이용한 JUnit 실행

* **``JUnitCore.main()``**이 필요없다.

* **@Test** 메서드만 있으면 실행가능

* 이클립스에서 ``Run As`` ➡ ``JUnit Test`` 실행

* 단축키 : ``alt + shift + x`` ➡ ``t``

* IDE를 사용할 경우, 패키지를 선택하고 실행할 경우, 해당 패키지의 모든 ``@Test``메서드를 실행한다.

* 프로젝트 단위로도 실행 가능하다.


### 3. 단위 테스트 작성시, 주의사항

* 코드가 바뀌지 않는다면, 동일한 테스트 결과를 얻을 수 있어야 한다.

* 외부환경(예: DB에 남아있는 데이터)에 의해 영향을 받아선 않된다.

* 테스트를 실행하는 순서가 변하더라도, 동일한 테스트 결과를 얻어야 한다.

* **성의없는(엉성한) 테스트는 가장 위험하다.**




## 🐫 JUnit - 예외가 발생해야 성공인 테스트

> DB에서 존재하지 않는 데이터를 조회 할 때, 예외를 발생시키도록 만들어 보자.

* 없는 데이터 조회시 발생시킬 예외 : EmptyResultDataAccessException

* ``org.springframework.transaction-3.0.7.RELEASE.jar`` 라이브러리에 해당 예외클래스가 있다.

* ``import org.springframework.dao.EmptyResultDataAccessException`` 필요

1. DAO클래스에서 ``select``결과가 없다면, **``EmptyResultDataAccessException``** 객체를 던진다.

1. ``@Test``메서드의 선언을 다음과 같이 한다.

```java
    @Test(expected = EmptyResultDataAccessException.class)
    public void 메서드명() {}
```




## 🐫 JUnit - 테스트 코드 개선 (@Before, 픽스처)

### 1. JUnit의 동작 방식

* 조건(``public, 반환값X, 인자X``)에 맞는 **@Test** 메서드를 모두 찾는다.

1. **@Test** 메서드 **하나당** 테스트 클래스의 객체를 생성한다.

1. **@Before** 메서드가 있다면, 실행한다.

1. **@Test** 메서드 하나를 호출하여 테스트 결과를 저장한다.

1. **@After** 메서드가 있다면, 실행한다.

* 위의 1 ~ 4 과정을 **@Test** 메서드 개수만큼 반복한다.

* 모든 결과를 종합해서 출력한다.

* **@Before** 메서드는 **@Test** 메서드를 실행하기 전에 수행하는 메서드

    일부 **@Test** 메서드에서만 선행되어야 할 동작은, 별도의 메서드로 추출하여 **@Test** 메서드 내에서 호출하는게 낫다.

* **@Test** 메서드가 속한 클래스의 모든 **@Test**클래스가 공통으로 선행작업 되야 할 동작을 정의하면 좋다.

* **@After** 메서드는 **@Test** 메서드가 종료된 후, 실행할 동작을 정의할 수 있다.


### 2. JUnit의 픽스처(fixture)

* **@Test** 메서드를 수행하는데 필요한 **정보**, **객체** 를 **픽스처(fixture)** 라고 한다.

* **@Before**, **@Test**, **@After** 메서드 간에 주고받을 **픽스처(fixture)**가 있다면, 필드변수로 만들어 사용하면 된다.


### 3. 스프링 테스트 컨텍스트 프레임워크 사용하기

* ``ApplicationContext``가 생성될 때는, 속하는 모든 ``Bean``객체가 생성 및 초기화 되기 때문에,

    매번 ``@Test`` 메서드를 수행할 때마다 ``ApplicationContext``를 생성하는 것은 문제점이 된다.

* ``ApplicationContext``는 모든 테스트에서 하나의 객체로 사용해도 되기 때문에, 전 테스트 과정에서 오직 한번만 객체를 생성하게 한다.

> 테스트 과정 중, ``ApplicationContext`` 객체를 딱 한번만 생성하게 만들기

1. ``**org.springframework.test-3.0.7.RELEASE.jar**`` 라이브러리 필요

1. ``ApplicationContext`` 타입의 인스턴스 변수를 만들고, **@AutoWired** 를 붙여준다.

1. 현재 테스트 클래스에 다음 두가지 애노테이션을 붙여준다.

    * **@RunWith(SpringJUnit4ClassRunner.class)**

        JUnit 프레임워크의 테스트 실행방법을 확장하는 애노테이션

    * **@ContextConfiguration("/경로")**

        자동으로 만들어줄 **애플리케이션 컨텍스트**의 **설정파일**을 지정

```java
    @RunWith(SpringJUnit4ClassRunner.class)
    @ContextConfiguration("/applicationContext.xml") 또는 (locations="applicationContext.xml")
    public class UserDaoTest {

        @AutoWired
        private ApplicationContext context;
        
        @Test
        public void 테스트메서드() { }
    }
```