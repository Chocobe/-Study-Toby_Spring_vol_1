# 3장. 템플릿




## 🐫 템플릿 개요

### 1. 템플릿 이란?

* **일정한 패턴으로 유지되는 부분**을 **자유롭게 변하는 부분**으로부터 독립시켜서 효과적으로 사용할 수 있도록 하는 방법

* 코드상에서 **동일한 부분**을 템플릿으로 만들어 **재사용**하는 방식이다.




## 🐫 변하지 않는 부분, 변하는 부분 나누기

* 변하는 부분과 변하지 않는 부분을 나누는 디자인 패턴으로는 **템플릿 메서드 패턴** 과 **전략 패턴**이 있다.


---


### 1. 템플릿 메서드 패턴

* **템플릿 메서드 패턴** 에서는 변하는 부분을 추상 메서드로 만들어, 자식 클래스에서 정의하여 사용하는 방법이다.

* 추상 메서드를 정의하는 **개수**만큼 자식클래스를 생성해야 하기 때문에 비효율 적이다.


---


### 2. 전략 패턴

* **전략 패턴** 에서는 변하는 부분을 인터페이스로 만들고, 필요한 정의만큼 클래스를 만들어 사용하는 방법이다.

* **템플릿 메서드 패던**과 다른점은, 인터페이스로 뽑아낸 **변하는 부분**은 익명 클래스로 작성할 수 있다는 점이다.

* **변하는 부분**을 익명 클래스로 만들 경우, 추가적인 클래스 파일이 필요없어서, **템플릿 메서드 패턴**보다 효율적이다.


---


### 3. 변하지 않는 부분 클래스로 추출하기

1. 변하지 않는 부분은 **변하는 부분**을 **전략패턴**의 인터페이스에 의존하게 만든다.

1. 변하지 않는 부분이 다른 클래스에서도 사용된다면, **개별 클래스**로 생성하면, 재사용율이 크게 증가한다.


---


### 4. 흐름 살펴보기

* 다음과 같은 *예* 에서 흐름

    * DAO : **클라이언트**

    * 변하는 부분 : **개별 전략**

    * 변하지 않는 부분 : **컨텍스트**

* **클라이언트** 가 **컨텍스트**에 **개별전략**을 사용하여 **메시지 전달**

* 만약, **컨텍스트**(변하지 않는 부분)이 테스트 단계와 운용단계 둘 다 변경할 이유가 없다면, 인터페이스 없이 **Bean(빈)**으로 사용해도 괜찮다.

* 단, 스프링의 DI는 런타임 의존관계를 만드는게 주 목적이기 때문에, 인터페이스에 의존하도록 한 후, 차후에 인터페이스를 삭제하여 강한 결합으로 만들지 결정하는것이 중요하다. (귀찮아서 인터페이스를 않쓰는 것은 최악의 시나리오)

---

> 어차피 **클라이언트**에 **컨텍스트**를 구체클래스로 DI할 것이라면, **수동 DI**로 만드는 방법도 있다.

* **클라이언트**는 **컨텍스트**의 구체 클래스를 이미 알고 있기 때문에, **클라이언트** 내부에서 직접 생성해서 사용하는 방법이다.

* 만약 **컨텍스트**에 DI 해줄 프로퍼티가 있다면, **클라이언트**가 DI받아서 직접 **컨텍스트**에 DI 해주면 된다.

---

* **클라이언트**와 **컨텍스트**의 **강한결합**방식은, 이유와 근거가 있을때만 사용해야 한다. 아니라면 인터페이스를 둔 DI를 사용하자.